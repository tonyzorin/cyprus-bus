Index: public/frontend.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>document.addEventListener('DOMContentLoaded', function () {\n    initMap();\n});\n\nlet map; // Declare map variable at the top level for global access\nlet busMarkers = []; // Array to store references to bus markers\nlet currentRoutePolyline = null; // This will store the current route polyline\n\nfunction initMap() {\n    // Initialize the map if it hasn't been already\n    if (!map) {\n        map = L.map('map', {\n            center: [34.679309, 33.037098],\n            zoom: 17,\n            attributionControl: false // Disable the default attribution control\n        });\n        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n            attribution: 'Â© OpenStreetMap contributors'\n        }).addTo(map);\n\n        // Add a new attribution control at the top right (\"topright\")\n        L.control.attribution({position: 'topright'}).addTo(map);\n    }\n    fetchStops();\n    fetchBusPositions();\n    showUserPosition();\n    setInterval(fetchBusPositions, 7000); // Refresh bus positions every 10 seconds\n}\n\nvar busStopIcon = L.icon({\n    iconUrl: './images/bus-stop.png',\n    iconSize: [16, 16],\n    iconAnchor: [16, 16],\n    popupAnchor: [0, -32]\n});\n\nvar busIcon = L.icon({\n    iconUrl: './images/pin0.png',\n    iconSize: [35, 47],\n    iconAnchor: [17.5, 35],\n    popupAnchor: [0, -47]\n});\n\nvar userIcon = L.icon({\n    iconUrl: './images/current-location.png',\n    iconSize: [40, 40],\n    iconAnchor: [24, 40],\n    popupAnchor: [0, 0]\n});\n\nfunction getbusIcon() {\n    return L.icon({\n        iconUrl: './images/pin0.png',\n        iconSize: [32, 47],\n        iconAnchor: [16, 47],\n        popupAnchor: [0, -47]\n    });\n}\nfunction fetchStops() {\n    fetch('/api/stops')\n        .then(response => response.json())\n        .then(stops => {\n            console.log(stops); // Log the stops data for debugging\n            stops.forEach(stop => {\n                L.marker([stop.lat, stop.lon], {icon: busStopIcon}).addTo(map)\n                    .bindPopup(`<b>${stop.name}</b>`);\n            });\n        })\n        .catch(error => console.error('Error fetching stops:', error));\n}\n\n\nfunction fetchBusPositions() {\n    fetch('/api/vehicle-positions')\n        .then(response => response.json())\n        .then(data => {\n            const newMarkers = {}; // Temporary storage for markers processed in this fetch\n\n            data.forEach(entity => {\n                //const latitude = entity.vehicle.position?.latitude;\n                //const longitude = entity.vehicle.position?.longitude;\n                const {routeShortName, routeLongName} = entity;\n                const {latitude, longitude} = entity.vehicle.position;\n                const vehicleLabel = entity.vehicle.vehicle.label;\n                if (busMarkers[vehicleLabel]) {\n                    moveMarkerSmoothly(busMarkers[vehicleLabel], [latitude, longitude]);\n                } else {\n                    const marker = L.marker([latitude, longitude], {icon: getbusIcon(routeShortName)}).addTo(map)\n                        .bindPopup(`Bus <b>${routeShortName}</b> (vehicle ${vehicleLabel})<br>${routeLongName}<br>Route ID: ${entity.routeId}`);\n                    marker.on('click', () => {\n                        if (entity.routeId) {\n                            onBusMarkerClick(entity.routeId);\n                        } else {\n                            console.error('routeId is undefined for vehicleLabel:', vehicleLabel);\n                        }\n                    });\n    // Assuming entity.routeId is available\n                    busMarkers[vehicleLabel] = marker;\n\n                }\n                newMarkers[vehicleLabel] = busMarkers[vehicleLabel];\n                // Determine the correct pin image based on route number\n                let pinImage = getbusIcon(routeShortName);\n\n                if (busMarkers[vehicleLabel]) {\n                    // Move existing marker smoothly to the new position\n                    moveMarkerSmoothly(busMarkers[vehicleLabel], [latitude, longitude]);\n                    // Update the icon if route has changed\n                    busMarkers[vehicleLabel].setIcon(getbusIcon());\n                } else {\n                    // Create a new marker and add it to the map with the determined icon\n                    const marker = L.marker([latitude, longitude], {icon: getBusIcon(routeShortName)}).addTo(map);\n                    bindPopup(`Bus <b>${routeShortName}</b> (vehicle ${vehicleLabel})<br>${routeLongName}<br>Route ID: ${entity.routeId}`);\n                    busMarkers[vehicleLabel] = marker;\n                }\n                // Add to newMarkers to keep track of which markers are still active\n                newMarkers[vehicleLabel] = busMarkers[vehicleLabel];\n            });\n\n            // Update busMarkers to reflect currently active markers\n            busMarkers = newMarkers;\n        })\n        .catch(error => console.error('Error fetching vehicle positions:', error));\n}\n\n\n\n\n// Function to determine the correct pin image based on the route number\nfunction getPinImage(routeShortName) {\n    let match = routeShortName.match(/^(\\d+)/);\n    let routeNumber = match ? match[1] : '0'; // Default to '0' if no numeric part is found\n    let pinImageFilename = `./images/pin${routeNumber}.png`;\n    return pinImageFilename;\n}\n\nfunction moveMarkerSmoothly(marker, newPosition) {\n    let latlngs = [marker.getLatLng(), L.latLng(newPosition)];\n    let index = 0;\n    let steps = 10;\n    let interval = setInterval(() => {\n        index++;\n        let fraction = index / steps;\n        let lat = latlngs[0].lat + (latlngs[1].lat - latlngs[0].lat) * fraction;\n        let lng = latlngs[0].lng + (latlngs[1].lng - latlngs[0].lng) * fraction;\n        marker.setLatLng([lat, lng]);\n        if (index === steps) clearInterval(interval);\n    }, 50); // Adjust timing for smoother animation\n}\n\nfunction onBusMarkerClick(routeId) {\n    fetch(`/api/route-shapes/${routeId}`)\n        .then(response => response.json())\n        .then(shapePoints => {\n            if (!Array.isArray(shapePoints) || shapePoints.length === 0) {\n                console.warn(\"No route shapes returned for routeId:\", routeId);\n                return; // Exit the function if no shapes were returned\n            }\n\n            // Remove the previous route from the map if it exists\n            if (currentRoutePolyline) {\n                map.removeLayer(currentRoutePolyline);\n                currentRoutePolyline = null; // Reset the currentRoutePolyline\n            }\n\n            const latLngs = shapePoints.map(point => [point.shape_pt_lat, point.shape_pt_lon]);\n            const routeColor = `#${shapePoints[0].route_color}`; // Extract color\n\n            if (latLngs.length > 0) {\n                // Create the polyline without altering the map's view\n                currentRoutePolyline = L.polyline(latLngs, {color: routeColor, weight: 6}).addTo(map);\n                // Do not call map.fitBounds() to avoid changing the zoom level and center\n            } else {\n                console.warn(\"Invalid or empty latLngs array for routeId:\", routeId);\n            }\n        })\n        .catch(error => console.error('Error fetching route shapes:', error));\n}\n\n\n\nfunction showUserPosition() {\n    if ('geolocation' in navigator) {\n        navigator.geolocation.getCurrentPosition(function(position) {\n            const lat = position.coords.latitude;\n            const lon = position.coords.longitude;\n\n            // Define custom HTML content that includes both the image and the beacon effect\n            const customHtmlContent = `\n                <div class=\"custom-marker-container\">\n                    <img src=\"images/current-location.png\" alt=\"current location\" class=\"user-icon\" />\n                    <div class=\"beacon\"></div> <!-- Beacon effect -->\n                </div>\n            `;\n\n            // Use Leaflet's DivIcon for the custom HTML content\n            const customIcon = L.divIcon({\n                className: 'custom-user-location-icon', // Custom class to avoid default leaflet marker styles\n                iconSize: [40, 40], // Adjust based on the size of your icon image + beacon size\n                html: customHtmlContent\n            });\n\n            // Create a marker with the custom icon and add it to the map\n            L.marker([lat, lon], {icon: customIcon}).addTo(map);\n\n            // Optionally, center the map on the user's location without changing the zoom level\n            map.panTo([lat, lon]);\n        }, function(error) {\n            console.error(\"Geolocation error:\", error);\n        }, {\n            enableHighAccuracy: true,\n            timeout: 5000,\n            maximumAge: 0\n        });\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/public/frontend.js b/public/frontend.js
--- a/public/frontend.js	
+++ b/public/frontend.js	
@@ -1,175 +1,410 @@
+const LOGGING_ENABLED = 1; // Set to 0 to disable logging
 document.addEventListener('DOMContentLoaded', function () {
     initMap();
 });
+let map;
+export function log(message, ...optionalParams) {
+    if (LOGGING_ENABLED) {
+        console.log(message, ...optionalParams);
+    }
+}
+
+let busPins = {};
+
+async function fetchStops(map, city) {
+    try {
+        const response = await fetch(`/api/stops/${city}`);
+        if (!response.ok) {
+            throw new Error(`HTTP error! status: ${response.status}`);
+        }
+        const stops = await response.json();
+        stops.forEach(stop => {
+            L.marker([stop.lat, stop.lon]).addTo(map)
+                .bindPopup(`<b>${stop.name}</b>`);
+        });
+    } catch (error) {
+        console.error('Error fetching stops:', error);
+    }
+}
+
+async function fetchBusPositions() {
+    try {
+        const response = await fetch('/api/vehicle-positions');
+        if (!response.ok) {
+            throw new Error(`HTTP error! status: ${response.status}`);
+        }
+        const data = await response.json();
 
-let map; // Declare map variable at the top level for global access
-let busMarkers = []; // Array to store references to bus markers
-let currentRoutePolyline = null; // This will store the current route polyline
+        // Clear previous error messages
+        document.getElementById("error-message").textContent = "";
 
-function initMap() {
-    // Initialize the map if it hasn't been already
+        // Check for specific error message from backend
+        if (data.error && data.error === "GTFS data is currently not available. Please try again later.") {
+            document.getElementById("error-message").textContent = "ð Error on getting buses positions from Motion. ð¤·â";
+            return; // Stop further processing
+        }
+
+        await processVehiclePositions(data);
+    } catch (error) {
+        console.error('Error fetching vehicle positions:', error);
+        // Update the UI to show a generic error message
+        document.getElementById("error-message").textContent = "ð Error on getting buses positions from Motion. ð¤·ï¸";
+    }
+}
+
+
+async function extractMarkerData(entity) {
+    const routeShortName = entity.routeShortName || "?";
+    const latitude = entity.vehicle.position.latitude;
+    const longitude = entity.vehicle.position.longitude;
+    const bearing = entity.vehicle.position.bearing || 0;
+    const vehicleLabel = entity.vehicle.vehicle.label || "N/A";
+    const routeColor = entity.routeColor.startsWith('#') ? entity.routeColor : `#${entity.routeColor}`;
+    const routeTextColor = entity.routeTextColor.startsWith('#') ? entity.routeTextColor : `#${entity.routeTextColor}`;// Wait for the icon to be fetched/created
+    const markerIcon = await fetchOrCreatePin(routeShortName, entity.routeColor, entity.routeTextColor);
+
+    return { latitude, longitude, markerIcon, vehicleLabel: entity.vehicle.vehicle.label };
+}
+
+export async function processVehiclePositions(data, map) {
+    const activeVehicleLabels = new Set(); // Track active vehicles
+
+    for (const entity of data) {
+        const { latitude, longitude, svgPin, vehicleLabel } = await extractPinData(entity);
+        activeVehicleLabels.add(vehicleLabel);
+
+        if (busPins[vehicleLabel]) {
+            movePinSmoothly(busPins[vehicleLabel], [latitude, longitude]);
+            updatePin(busPins[vehicleLabel], svgPin);
+        } else {
+            busPins[vehicleLabel] = createNewPin(latitude, longitude, svgPin, entity, map);
+        }
+    }
+
+    cleanupPins(activeVehicleLabels);
+}
+
+async function extractPinData(entity) {
+    const routeShortName = entity.routeShortName || "?";
+    const latitude = entity.vehicle.position.latitude;
+    const longitude = entity.vehicle.position.longitude;
+    const svgPin = generateSvgPin(routeShortName, entity.routeColor, entity.routeTextColor, entity.vehicle.position.bearing || 0);
+    return { latitude, longitude, svgPin, vehicleLabel: entity.vehicle.vehicle.label };
+}
+
+function generateSvgPin(routeShortName, routeColor, routeTextColor, bearing) {
+    routeColor = routeColor.startsWith('#') ? routeColor : `#${routeColor}`;
+    routeTextColor = routeTextColor.startsWith('#') ? routeTextColor : `#${routeTextColor}`;
+    const svgContent = `
+        <svg class="svg-pin" width="70" height="95" viewBox="0 0 70 95" xmlns="http://www.w3.org/2000/svg">
+            <g transform="rotate(${bearing}, 35, 47.5)">
+                <path d="M34.9556 94.6442C34.0638 94.651 33.1921 94.3771 32.462 93.8607C31.7319 93.3443 31.1797 92.6112 30.8825 91.7634C26.3231 79.0907 9.31643 60.1199 9.13405 59.9207L9.02766 59.7828C4.49113 54.7241 1.50766 48.4471 0.43903 41.7129C-0.629603 34.9786 0.262503 28.0764 3.00718 21.8431C5.75186 15.6099 10.2312 10.3135 15.902 6.59609C21.5729 2.87869 28.1916 0.900024 34.9556 0.900024C41.7195 0.900024 48.3383 2.87869 54.0091 6.59609C59.6799 10.3135 64.1593 15.6099 66.9039 21.8431C69.6486 28.0764 70.5407 34.9786 69.4721 41.7129C68.4035 48.4471 65.42 54.7241 60.8834 59.7828L60.7771 59.9207C60.5947 60.1199 43.588 79.0907 39.0286 91.7634C38.7333 92.6124 38.1817 93.3469 37.4511 93.8636C36.7206 94.3803 35.8479 94.6533 34.9556 94.6442Z" fill="${routeColor}"/>
+                <text x="35" y="40" text-anchor="middle" fill="${routeTextColor}" dy=".3em" style="font-size: 22px;">${routeShortName}</text>
+            </g>
+        </svg>
+    `;
+    return svgContent;
+}
+
+
+
+function updatePin(pinElement, svgPin) {
+    const div = document.createElement('div');
+    div.innerHTML = svgPin;
+    const newPinElement = div.firstChild;
+
+    if (newPinElement && pinElement) {
+        pinElement.parentNode.replaceChild(newPinElement, pinElement);
+
+        newPinElement.addEventListener('click', () => {
+            const popupContent = pinElement._popupContent;
+            const popup = L.popup()
+                .setLatLng([newPinElement._lat, newPinElement._lng])
+                .setContent(popupContent)
+                .openOn(map);
+        });
+
+        return newPinElement;
+    } else {
+        console.error('Error updating pin: newPinElement or pinElement is null or undefined.');
+    }
+}
+
+function movePinSmoothly(pinElement, newPosition) {
+    const startLatLng = map.layerPointToLatLng(L.point(parseFloat(pinElement.style.left), parseFloat(pinElement.style.top)));
+    const endLatLng = L.latLng(newPosition);
+
+    const distance = startLatLng.distanceTo(endLatLng);
+    const steps = distance / 10;
+    const stepLat = (endLatLng.lat - startLatLng.lat) / steps;
+    const stepLng = (endLatLng.lng - startLatLng.lng) / steps;
+    let i = 0;
+
+    const interval = setInterval(() => {
+        if (i < steps) {
+            i++;
+            const newLatLng = L.latLng(startLatLng.lat + stepLat * i, startLatLng.lng + stepLng * i);
+            const newPoint = map.latLngToLayerPoint(newLatLng);
+            pinElement.style.left = `${newPoint.x - 35}px`;
+            pinElement.style.top = `${newPoint.y - 47.5}px`;
+        } else {
+            clearInterval(interval);
+            const finalPoint = map.latLngToLayerPoint(endLatLng);
+            pinElement.style.left = `${finalPoint.x - 35}px`;
+            pinElement.style.top = `${finalPoint.y - 47.5}px`;
+        }
+    }, 20);
+}
+
+
+
+async function initMap(city) {
     if (!map) {
         map = L.map('map', {
             center: [34.679309, 33.037098],
-            zoom: 17,
+            zoom: 9,
+            zoomControl: true,
+            scrollWheelZoom: true, // Enable scroll wheel zoom
             attributionControl: false // Disable the default attribution control
         });
         L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
             attribution: 'Â© OpenStreetMap contributors'
         }).addTo(map);
 
-        // Add a new attribution control at the top right ("topright")
-        L.control.attribution({position: 'topright'}).addTo(map);
+        L.control.attribution({ position: 'topright' }).addTo(map);
     }
-    fetchStops();
-    fetchBusPositions();
-    showUserPosition();
-    setInterval(fetchBusPositions, 7000); // Refresh bus positions every 10 seconds
-}
+
+    // Clear previous layers
+    map.eachLayer(layer => {
+        if (layer.options && layer.options.pane !== 'tilePane') {
+            map.removeLayer(layer);
+        }
+    });
+
+    await fetchStops(map, city);
+    await fetchBusPositions(map, city);
+    showUserPosition(map);
 
-var busStopIcon = L.icon({
-    iconUrl: './images/bus-stop.png',
-    iconSize: [16, 16],
-    iconAnchor: [16, 16],
-    popupAnchor: [0, -32]
-});
+    setInterval(() => fetchBusPositions(map, city), 10000); // Refresh bus positions every 10 seconds
+}
+
+document.addEventListener('DOMContentLoaded', function () {
+    const loadMapButton = document.getElementById('loadMap');
+    loadMapButton.addEventListener('click', function () {
+        const city = document.getElementById('city').value;
+        initMap(city);
+    });
 
-var busIcon = L.icon({
-    iconUrl: './images/pin0.png',
-    iconSize: [35, 47],
-    iconAnchor: [17.5, 35],
-    popupAnchor: [0, -47]
+    // Load the map with a default city initially
+    const defaultCity = 'Limassol'; // Change 'Limassol' to your desired default city
+    initMap(defaultCity);
 });
 
-var userIcon = L.icon({
-    iconUrl: './images/current-location.png',
-    iconSize: [40, 40],
-    iconAnchor: [24, 40],
-    popupAnchor: [0, 0]
-});
+function showUserPosition(map) {
+    if ('geolocation' in navigator) {
+        navigator.geolocation.getCurrentPosition(function(position) {
+            const lat = position.coords.latitude;
+            const lon = position.coords.longitude;
+
+            const customHtmlContent = `
+                <div class="custom-marker-container">
+                    <img src="images/current-location.png" alt="current location" class="user-icon on-top"/>
+                    <div class="beacon"></div>
+                </div>
+            `;
+
+            const customIcon = L.divIcon({
+                className: 'custom-user-location-icon z-index=1200',
+                iconSize: [40, 40],
+                html: customHtmlContent
+            });
+
+            L.marker([lat, lon], {icon: customIcon}).addTo(map);
+            map.setView([lat, lon], 16);
+        }, function(error) {
+            console.error("Geolocation error:", error);
+        }, {
+            enableHighAccuracy: true,
+            timeout: 5000,
+            maximumAge: 0
+        });
+    }
+}
 
-function getbusIcon() {
+async function fetchOrCreatePin(routeShortName, routeColor, routeTextColor) {
+    routeColor = routeColor.startsWith('#') ? routeColor : `#${routeColor}`;
+    routeTextColor = routeTextColor.startsWith('#') ? routeTextColor : `#${routeTextColor}`;
+    const svgContent = `
+        <svg width="70" height="95" viewBox="0 0 70 95" fill="${routeColor}" xmlns="http://www.w3.org/2000/svg" transform="rotate(${bearing} 35 40)">
+            <path d="M34.9556 94.6442C34.0638 94.651 33.1921 94.3771 32.462 93.8607C31.7319 93.3443 31.1797 92.6112 30.8825 91.7634C26.3231 79.0907 9.31643 60.1199 9.13405 59.9207L9.02766 59.7828C4.49113 54.7241 1.50766 48.4471 0.43903 41.7129C-0.629603 34.9786 0.262503 28.0764 3.00718 21.8431C5.75186 15.6099 10.2312 10.3135 15.902 6.59609C21.5729 2.87869 28.1916 0.900024 34.9556 0.900024C41.7195 0.900024 48.3383 2.87869 54.0091 6.59609C59.6799 10.3135 64.1593 15.6099 66.9039 21.8431C69.6486 28.0764 70.5407 34.9786 69.4721 41.7129C68.4035 48.4471 65.42 54.7241 60.8834 59.7828L60.7771 59.9207C60.5947 60.1199 43.588 79.0907 39.0286 91.7634C38.7333 92.6124 38.1817 93.3469 37.4511 93.8636C36.7206 94.3803 35.8479 94.6533 34.9556 94.6442Z" fill="${routeColor}"/>
+            <text x="35" y="40" text-anchor="middle" fill="${routeTextColor}" dy=".3em" style="font-size: 22px;" transform="rotate(-${bearing} 35 40)">${routeShortName}</text>
+        </svg>
+    `;
+    const encodedSvg = encodeURIComponent(svgContent);
+    const iconUrl = `data:image/svg+xml;charset=UTF-8,${encodedSvg}`;
     return L.icon({
-        iconUrl: './images/pin0.png',
+        iconUrl: iconUrl,
         iconSize: [32, 47],
         iconAnchor: [16, 47],
         popupAnchor: [0, -47]
     });
 }
-function fetchStops() {
-    fetch('/api/stops')
-        .then(response => response.json())
-        .then(stops => {
-            console.log(stops); // Log the stops data for debugging
-            stops.forEach(stop => {
-                L.marker([stop.lat, stop.lon], {icon: busStopIcon}).addTo(map)
-                    .bindPopup(`<b>${stop.name}</b>`);
-            });
-        })
-        .catch(error => console.error('Error fetching stops:', error));
+export async function moveMarkerSmoothly(marker, newPosition) {
+    let currentLatLng = marker.getLatLng();
+    let newLatLng = L.latLng(newPosition);
+    let distance = currentLatLng.distanceTo(newLatLng);
+    let steps = distance / 10;
+    let stepLat = (newLatLng.lat - currentLatLng.lat) / steps;
+    let stepLng = (newLatLng.lng - currentLatLng.lng) / steps;
+    let i = 0;
+    let interval = setInterval(() => {
+        if (i < steps) {
+            i++;
+            marker.setLatLng([currentLatLng.lat + (stepLat * i), currentLatLng.lng + (stepLng * i)]);
+        } else {
+            clearInterval(interval);
+            marker.setLatLng(newLatLng);
+        }
+    }, 20);
 }
 
+async function createNewMarker(latitude, longitude, markerIcon, entity, map) {
+    console.log('Creating new marker...');
+    console.log('Latitude:', latitude);
+    console.log('Longitude:', longitude);
+    console.log('Marker icon:', markerIcon);
+    console.log('Entity:', entity);
 
-function fetchBusPositions() {
-    fetch('/api/vehicle-positions')
-        .then(response => response.json())
-        .then(data => {
-            const newMarkers = {}; // Temporary storage for markers processed in this fetch
+    const bearing = entity.vehicle.position.bearing || 0; // Use 0 as default if undefined
+    console.log('Bearing:', bearing);
 
-            data.forEach(entity => {
-                //const latitude = entity.vehicle.position?.latitude;
-                //const longitude = entity.vehicle.position?.longitude;
-                const {routeShortName, routeLongName} = entity;
-                const {latitude, longitude} = entity.vehicle.position;
-                const vehicleLabel = entity.vehicle.vehicle.label;
-                if (busMarkers[vehicleLabel]) {
-                    moveMarkerSmoothly(busMarkers[vehicleLabel], [latitude, longitude]);
-                } else {
-                    const marker = L.marker([latitude, longitude], {icon: getbusIcon(routeShortName)}).addTo(map)
-                        .bindPopup(`Bus <b>${routeShortName}</b> (vehicle ${vehicleLabel})<br>${routeLongName}<br>Route ID: ${entity.routeId}`);
-                    marker.on('click', () => {
-                        if (entity.routeId) {
-                            onBusMarkerClick(entity.routeId);
-                        } else {
-                            console.error('routeId is undefined for vehicleLabel:', vehicleLabel);
-                        }
-                    });
-    // Assuming entity.routeId is available
-                    busMarkers[vehicleLabel] = marker;
-
-                }
-                newMarkers[vehicleLabel] = busMarkers[vehicleLabel];
-                // Determine the correct pin image based on route number
-                let pinImage = getbusIcon(routeShortName);
-
-                if (busMarkers[vehicleLabel]) {
-                    // Move existing marker smoothly to the new position
-                    moveMarkerSmoothly(busMarkers[vehicleLabel], [latitude, longitude]);
-                    // Update the icon if route has changed
-                    busMarkers[vehicleLabel].setIcon(getbusIcon());
-                } else {
-                    // Create a new marker and add it to the map with the determined icon
-                    const marker = L.marker([latitude, longitude], {icon: getBusIcon(routeShortName)}).addTo(map);
-                    bindPopup(`Bus <b>${routeShortName}</b> (vehicle ${vehicleLabel})<br>${routeLongName}<br>Route ID: ${entity.routeId}`);
-                    busMarkers[vehicleLabel] = marker;
-                }
-                // Add to newMarkers to keep track of which markers are still active
-                newMarkers[vehicleLabel] = busMarkers[vehicleLabel];
-            });
+    const routeShortName = entity.routeShortName || "?";
+    const routeTextColor = entity.routeTextColor || "#000000"; // Default to black if undefined
+    const validRouteTextColor = routeTextColor.startsWith('#') ? routeTextColor : `#${routeTextColor}`;
+    console.log('Route short name:', routeShortName);
+    console.log('Route text color:', validRouteTextColor);
+
+    const customHtmlContent = `
+        <div style="position: relative; font-size: 12px; text-align: center; width: 70px;">
+            <div style="position: relative; top: 78%; left: 78%; transform: translateX(-50%) rotate(${bearing}deg);">
+                <img src="${markerIcon.options.iconUrl}" style="width: 32px; height: 47px;">
+                <div style="position: absolute; top: 22%; left: 22%; transform: translateX(-50%) rotate(-${bearing}deg); color: ${validRouteTextColor};">
+                ${routeShortName}
+            </div>
+            </div>
+        </div>
+    `;
+    const customIcon = L.divIcon({
+        html: customHtmlContent,
+        iconSize: [70, 95], // Adjusted to contain both the pin and text
+        iconAnchor: [35, 47.5], // Centered anchor point
+        popupAnchor: [0, -47.5] // Adjust if necessary
+    });
+    console.log('Custom icon created.');
+
+    if (busMarkers[entity.vehicle.vehicle.label]) {
+        console.log('Updating existing marker for vehicle label:', entity.vehicle.vehicle.label);
+        busMarkers[entity.vehicle.vehicle.label].setLatLng([latitude, longitude]).setIcon(customIcon);
+    } else {
+        console.log('Creating new marker for vehicle label:', entity.vehicle.vehicle.label);
+        busMarkers[entity.vehicle.vehicle.label] = L.marker([latitude, longitude], { icon: customIcon }).addTo(map);
+        busMarkers[entity.vehicle.vehicle.label].bindPopup(generatePopupContent(entity));
+    }
+
+    busMarkers[entity.vehicle.vehicle.label].on('click', () => onBusMarkerClick(entity.routeId));
+    console.log('Marker created and added to map.');
+
+    return busMarkers[entity.vehicle.vehicle.label]; // Return the Leaflet marker instance
+}
+
+function createNewPin(latitude, longitude, svgPin, entity, map) {
+    const div = document.createElement('div');
+    div.innerHTML = svgPin;
+    const pinElement = div.firstChild;
+
+    if (pinElement) {
+        const mapContainer = document.getElementById('map');
+        if (mapContainer) {
+            const latLng = map.latLngToLayerPoint([latitude, longitude]);
+            pinElement.style.left = `${latLng.x - 35}px`; // Center the pin
+            pinElement.style.top = `${latLng.y - 47.5}px`; // Center the pin
+            pinElement.style.position = 'absolute';
+
+            mapContainer.appendChild(pinElement);
+
+            pinElement.addEventListener('click', () => {
+                const popupContent = generatePopupContent(entity);
+                const popup = L.popup()
+                    .setLatLng([latitude, longitude])
+                    .setContent(popupContent)
+                    .openOn(map);
+            });
+
+            return pinElement;
+        } else {
+            console.error('Error: map container element not found.');
+        }
+    } else {
+        console.error('Error creating pin: pinElement is null or undefined.');
+    }
+}
 
-            // Update busMarkers to reflect currently active markers
-            busMarkers = newMarkers;
-        })
-        .catch(error => console.error('Error fetching vehicle positions:', error));
+function generatePopupContent(entity) {
+    if (!entity || !entity.routeId) {
+        return 'Information unavailable';
+    }
+    return `
+        <div>Route Short Name: ${entity.routeShortName}</div>
+        <div>Route ID: ${entity.routeId}</div>
+         (vehicle ${entity.vehicle.vehicle.label})<br>
+                ${entity.routeLongName}<br>Route ID: ${entity.routeId}<br>Bearing: ${entity.vehicle.position.bearing || "N/A"}<br>
+                Route color: ${entity.routeColor || "N/A"}<br>Text color: ${entity.routeTextColor || "N/A"}<br>
+                Speed: ${Math.round(entity.vehicle.position.speed) || 0}
+    `;
 }
-
-
-
 
-// Function to determine the correct pin image based on the route number
-function getPinImage(routeShortName) {
-    let match = routeShortName.match(/^(\d+)/);
-    let routeNumber = match ? match[1] : '0'; // Default to '0' if no numeric part is found
-    let pinImageFilename = `./images/pin${routeNumber}.png`;
-    return pinImageFilename;
+function cleanupPins(activeVehicleLabels) {
+    Object.keys(busPins).forEach(vehicleLabel => {
+        if (!activeVehicleLabels.has(vehicleLabel)) {
+            if (busPins[vehicleLabel]) {
+                busPins[vehicleLabel].remove(); // Remove from map
+            }
+            delete busPins[vehicleLabel];
+        }
+    });
+    console.log('Cleaned up inactive bus pins.');
 }
 
-function moveMarkerSmoothly(marker, newPosition) {
-    let latlngs = [marker.getLatLng(), L.latLng(newPosition)];
-    let index = 0;
-    let steps = 10;
-    let interval = setInterval(() => {
-        index++;
-        let fraction = index / steps;
-        let lat = latlngs[0].lat + (latlngs[1].lat - latlngs[0].lat) * fraction;
-        let lng = latlngs[0].lng + (latlngs[1].lng - latlngs[0].lng) * fraction;
-        marker.setLatLng([lat, lng]);
-        if (index === steps) clearInterval(interval);
-    }, 50); // Adjust timing for smoother animation
-}
+
+export async function onBusMarkerClick(routeId) {
+    if (routeId === "") {
+        console.warn("Route details are unknown. Cannot fetch route shapes.");
+        return;
+    }
 
-function onBusMarkerClick(routeId) {
     fetch(`/api/route-shapes/${routeId}`)
-        .then(response => response.json())
+        .then(response => {
+            if (!response.ok) {
+                throw new Error(`HTTP error! status: ${response.status}`);
+            }
+            return response.json();
+        })
         .then(shapePoints => {
             if (!Array.isArray(shapePoints) || shapePoints.length === 0) {
                 console.warn("No route shapes returned for routeId:", routeId);
-                return; // Exit the function if no shapes were returned
+                return;
             }
 
-            // Remove the previous route from the map if it exists
             if (currentRoutePolyline) {
                 map.removeLayer(currentRoutePolyline);
-                currentRoutePolyline = null; // Reset the currentRoutePolyline
+                currentRoutePolyline = null;
             }
 
             const latLngs = shapePoints.map(point => [point.shape_pt_lat, point.shape_pt_lon]);
-            const routeColor = `#${shapePoints[0].route_color}`; // Extract color
+            const routeColor = `#${shapePoints[0].route_color}`;
 
             if (latLngs.length > 0) {
-                // Create the polyline without altering the map's view
                 currentRoutePolyline = L.polyline(latLngs, {color: routeColor, weight: 6}).addTo(map);
-                // Do not call map.fitBounds() to avoid changing the zoom level and center
             } else {
                 console.warn("Invalid or empty latLngs array for routeId:", routeId);
             }
@@ -177,40 +412,14 @@
         .catch(error => console.error('Error fetching route shapes:', error));
 }
 
-
-
-function showUserPosition() {
-    if ('geolocation' in navigator) {
-        navigator.geolocation.getCurrentPosition(function(position) {
-            const lat = position.coords.latitude;
-            const lon = position.coords.longitude;
-
-            // Define custom HTML content that includes both the image and the beacon effect
-            const customHtmlContent = `
-                <div class="custom-marker-container">
-                    <img src="images/current-location.png" alt="current location" class="user-icon" />
-                    <div class="beacon"></div> <!-- Beacon effect -->
-                </div>
-            `;
-
-            // Use Leaflet's DivIcon for the custom HTML content
-            const customIcon = L.divIcon({
-                className: 'custom-user-location-icon', // Custom class to avoid default leaflet marker styles
-                iconSize: [40, 40], // Adjust based on the size of your icon image + beacon size
-                html: customHtmlContent
-            });
-
-            // Create a marker with the custom icon and add it to the map
-            L.marker([lat, lon], {icon: customIcon}).addTo(map);
-
-            // Optionally, center the map on the user's location without changing the zoom level
-            map.panTo([lat, lon]);
-        }, function(error) {
-            console.error("Geolocation error:", error);
-        }, {
-            enableHighAccuracy: true,
-            timeout: 5000,
-            maximumAge: 0
-        });
-    }
+export function cleanupMarkers(activeVehicleLabels) {
+    Object.keys(busMarkers).forEach(vehicleLabel => {
+        if (!activeVehicleLabels.has(vehicleLabel)) {
+            if (busMarkers[vehicleLabel].remove) {
+                busMarkers[vehicleLabel].remove(); // Remove from map
+            }
+            delete busMarkers[vehicleLabel];
+        }
+    });
+    console.log('Cleaned up inactive bus markers.');
 }
Index: public/index.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><!DOCTYPE html>\n<html>\n<head>\n    <title>Cyprus Buses Live</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet/dist/leaflet.css\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <style>\n        /* Make the map container full screen */\n        #map {\n            height: 90vh; /* Use 100% of the viewport height */\n            width: 100vw; /* Use 100% of the viewport width */\n            position: absolute; /* Optional: Makes the map more responsive to screen size changes */\n            top: 0;\n            left: 0;\n        }\n        body, html {\n            height: 100%; /* Ensure the body and html take the full height of the viewport */\n            margin: 0; /* Remove default margin */\n            padding: 0; /* Remove default padding */\n        }\n        h3 {\n            position: absolute;\n            z-index: 1000; /* Ensure the heading appears above the map */\n            margin-left: 60px; /* Adjust as needed */\n            background-color: white; /* Make it visible on top of the map */\n            padding: 5px;\n            border-radius: 5px;\n        }\n        .marker {\n            transform: perspective(40px) rotateX(20deg) rotateZ(-45deg);\n            transform-origin: 50% 50%;\n            border-radius: 50% 50% 50% 0;\n            padding: 0 0 0 0;\n            width: 40px;\n            height: 40px;\n            background: #ed1f34;\n            position: absolute;\n            left: 50%;\n            top: 50%;\n            margin: -2.2em 0 0 -1.3em;\n            -webkit-box-shadow: -1px 1px 4px rgba(0, 0, 0, .5);\n            -moz-box-shadow: -1px 1px 4px rgba(0, 0, 0, .5);\n            box-shadow: -1px 1px 4px rgba(0, 0, 0, .5);\n        }\n\n        .beacon-effect::before {\n            content: '';\n            display: block;\n            width: 100%;\n            height: 100%;\n            background: rgba(0, 0, 255, 0.3); // Blue color\n        border-radius: 50%;\n            animation: pulse-animation 2s infinite;\n        }\n\n        @keyframes pulse-animation {\n            0% { transform: scale(0.5); opacity: 1; }\n            100% { transform: scale(1.5); opacity: 0; }\n        }\n\n        .marker:after {\n            content: '';\n            width: 1em;\n            height: 1em;\n            margin: 1em 0 0 .7em;\n            background: #ffffff;\n            position: absolute;\n            border-radius: 50%;\n            -moz-box-shadow: 0 0 10px rgba(0, 0, 0, .5);\n            -webkit-box-shadow: 0 0 10px rgba(0, 0, 0, .5);\n            box-shadow: 0 0 10px rgba(0, 0, 0, .5);\n            -moz-box-shadow: inset -2px 2px 4px hsla(0, 0, 0, .5);\n            -webkit-box-shadow: inset -2px 2px 4px hsla(0, 0, 0, .5);\n            box-shadow: inset -2px 2px 4px hsla(0, 0, 0, .5);\n        }\n        .beacon {\n            position: absolute;\n            top: 0;\n            left: 0;\n            height: 50px; /* The beacon effect will be slightly larger than the icon */\n            width: 50px;\n            border-radius: 50%;\n            transform: translate(0%, 0%);\n            z-index: 1; /* Lower than the icon */\n        }\n        .user-icon {\n            width: 50px; /* Width of the user icon */\n            height: 50px; /* Height of the user icon */\n            position: absolute;\n            left: 50%;\n            top: 50%;\n            transform: translate(-50%, -50%);\n            z-index: 2; /* Higher than the beacon effect */\n        }\n\n        .beacon-effect::before {\n            content: '';\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            background: rgba(0, 0, 255, 0.3);\n            border-radius: 50%;\n            animation: pulse-animation 2s infinite;\n            z-index: 1; /* Same as .beacon to keep effect beneath the icon */\n        }\n        .beacon:after {\n            position: absolute;\n            content: \"\";\n            height: 3em;\n            width: 3em;\n            left: 0;\n            top: 0;\n            background-color: transparent;\n            border-radius: 50%;\n            box-shadow: 0 0 0 3px #1f41ed;\n            -webkit-animation: active 2s infinite linear;\n            -moz-animation: active 2s infinite linear;\n            animation: active 3s infinite linear;\n        }\n        .menu-item.active {\n            background-color: #007bff; /* Example active color, adjust as needed */\n            color: white;\n        }\n        .menu-item {\n            background-color: #000000 0.7; /* Example active color, adjust as needed */\n            color: white;\n        }\n        .bottom-menu {\n            display: flex;\n            justify-content: space-around;\n            position: fixed;\n            bottom: 0;\n            left: 0;\n            right: 0;\n            width: 100%;\n            height: 50px;\n            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black */\n            color: white;\n            z-index: 1001;\n        }\n        @media (max-width: 768px) {\n            .bottom-menu {\n                height: 40px; /* Adjust for mobile */\n            }\n        }\n\n        @-webkit-keyframes active {\n            0% {\n                -webkit-transform: scale(.1);\n                opacity: 1;\n            }\n            100% {\n                -webkit-transform: scale(2.5);\n                opacity: 0;\n            }\n        }\n\n        @keyframes-blue active {\n            0% {\n                transform: scale(.1);\n                transform: box-shadow(0px 0px 0px 1px #1f41ed);\n                opacity: 1;\n            }\n            100% {\n                transform: scale(2.5);\n                opacity: 0;\n            }\n        }\n    </style>\n    <script>\n        !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(\".\");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement(\"script\")).type=\"text/javascript\",p.async=!0,p.src=s.api_host+\"/static/array.js\",(r=t.getElementsByTagName(\"script\")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a=\"posthog\",u.people=u.people||[],u.toString=function(t){var e=\"posthog\";return\"posthog\"!==a&&(e+=\".\"+a),t||(e+=\" (stub)\"),e},u.people.toString=function(){return u.toString(1)+\".people (stub)\"},o=\"capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags getFeatureFlag getFeatureFlagPayload reloadFeatureFlags group updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures getActiveMatchingSurveys getSurveys onSessionId\".split(\" \"),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);\n        posthog.init('phc_7JBpU7pfJomlCDgtNh0GgygKClYpYU52HOBX36qZRZx',{api_host:'https://eu.posthog.com'})\n    </script>\n</head>\n<body>\n<script>!function(t,e,a,n){function o(){if(!e.getElementById(a)){var t=e.getElementsByTagName(n)[0],o=e.createElement(n);o.type=\"text/javascript\",o.async=!0,o.src=\"https://cdn.prodcamp.com/js/prdcmp-sdk.js\",t.parentNode.insertBefore(o,t)}}if(\"function\"!=typeof t.ProdCamp){var c=function(){c.args.push(arguments)};c.p=\"XHNWXMHQK\",c.args=[],c.t=t.ProdCampSettings&&t.ProdCampSettings.token,c.f=true,t.ProdCamp=c,\"complete\"===e.readyState?o():t.attachEvent?t.attachEvent(\"onload\",o):t.addEventListener(\"load\",o,!1)}}(window,document,\"prodcamp-js\",\"script\");</script>\n<script>\n    ProdCamp('initFeedbackWidget', {\n        email: 'random@mail.com'\n    });\n</script>\n<h3>Cyprus Buses Live</h3>\n<div id=\"map\"></div>\n<script src=\"https://unpkg.com/leaflet/dist/leaflet.js\"></script>\n<script src=\"./frontend.js\"></script>\n<div class=\"bottom-menu\">\n    <div><a href=\"#\" class=\"menu-item active\">Map</a></div>\n    <div><a href=\"#\" class=\"menu-item\">Timetables (soon)</a></div>\n    <div><a href=\"#\" class=\"menu-item\">Routes (soon)</a></div>\n    <div><a href=\"#\" class=\"menu-item\">About (soon)</a></div>\n</div>\n<script>\n    document.addEventListener('DOMContentLoaded', () => {\n        const menuItems = document.querySelectorAll('.menu-item');\n\n        menuItems.forEach(item => {\n            item.addEventListener('click', function() {\n                menuItems.forEach(i => i.classList.remove('active')); // Remove active class from all items\n                this.classList.add('active'); // Add active class to the clicked item\n            });\n        });\n    });\n</script>\n</body>\n</html>\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/public/index.html b/public/index.html
--- a/public/index.html	
+++ b/public/index.html	
@@ -1,205 +1,80 @@
 <!DOCTYPE html>
 <html>
 <head>
-    <title>Cyprus Buses Live</title>
-    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
-    <meta name="viewport" content="width=device-width, initial-scale=1">
-    <style>
-        /* Make the map container full screen */
-        #map {
-            height: 90vh; /* Use 100% of the viewport height */
-            width: 100vw; /* Use 100% of the viewport width */
-            position: absolute; /* Optional: Makes the map more responsive to screen size changes */
-            top: 0;
-            left: 0;
-        }
-        body, html {
-            height: 100%; /* Ensure the body and html take the full height of the viewport */
-            margin: 0; /* Remove default margin */
-            padding: 0; /* Remove default padding */
-        }
-        h3 {
-            position: absolute;
-            z-index: 1000; /* Ensure the heading appears above the map */
-            margin-left: 60px; /* Adjust as needed */
-            background-color: white; /* Make it visible on top of the map */
-            padding: 5px;
-            border-radius: 5px;
-        }
-        .marker {
-            transform: perspective(40px) rotateX(20deg) rotateZ(-45deg);
-            transform-origin: 50% 50%;
-            border-radius: 50% 50% 50% 0;
-            padding: 0 0 0 0;
-            width: 40px;
-            height: 40px;
-            background: #ed1f34;
-            position: absolute;
-            left: 50%;
-            top: 50%;
-            margin: -2.2em 0 0 -1.3em;
-            -webkit-box-shadow: -1px 1px 4px rgba(0, 0, 0, .5);
-            -moz-box-shadow: -1px 1px 4px rgba(0, 0, 0, .5);
-            box-shadow: -1px 1px 4px rgba(0, 0, 0, .5);
-        }
-
-        .beacon-effect::before {
-            content: '';
-            display: block;
-            width: 100%;
-            height: 100%;
-            background: rgba(0, 0, 255, 0.3); // Blue color
-        border-radius: 50%;
-            animation: pulse-animation 2s infinite;
-        }
-
-        @keyframes pulse-animation {
-            0% { transform: scale(0.5); opacity: 1; }
-            100% { transform: scale(1.5); opacity: 0; }
-        }
-
-        .marker:after {
-            content: '';
-            width: 1em;
-            height: 1em;
-            margin: 1em 0 0 .7em;
-            background: #ffffff;
-            position: absolute;
-            border-radius: 50%;
-            -moz-box-shadow: 0 0 10px rgba(0, 0, 0, .5);
-            -webkit-box-shadow: 0 0 10px rgba(0, 0, 0, .5);
-            box-shadow: 0 0 10px rgba(0, 0, 0, .5);
-            -moz-box-shadow: inset -2px 2px 4px hsla(0, 0, 0, .5);
-            -webkit-box-shadow: inset -2px 2px 4px hsla(0, 0, 0, .5);
-            box-shadow: inset -2px 2px 4px hsla(0, 0, 0, .5);
-        }
-        .beacon {
-            position: absolute;
-            top: 0;
-            left: 0;
-            height: 50px; /* The beacon effect will be slightly larger than the icon */
-            width: 50px;
-            border-radius: 50%;
-            transform: translate(0%, 0%);
-            z-index: 1; /* Lower than the icon */
-        }
-        .user-icon {
-            width: 50px; /* Width of the user icon */
-            height: 50px; /* Height of the user icon */
-            position: absolute;
-            left: 50%;
-            top: 50%;
-            transform: translate(-50%, -50%);
-            z-index: 2; /* Higher than the beacon effect */
-        }
-
-        .beacon-effect::before {
-            content: '';
-            position: absolute;
-            width: 100%;
-            height: 100%;
-            background: rgba(0, 0, 255, 0.3);
-            border-radius: 50%;
-            animation: pulse-animation 2s infinite;
-            z-index: 1; /* Same as .beacon to keep effect beneath the icon */
-        }
-        .beacon:after {
-            position: absolute;
-            content: "";
-            height: 3em;
-            width: 3em;
-            left: 0;
-            top: 0;
-            background-color: transparent;
-            border-radius: 50%;
-            box-shadow: 0 0 0 3px #1f41ed;
-            -webkit-animation: active 2s infinite linear;
-            -moz-animation: active 2s infinite linear;
-            animation: active 3s infinite linear;
-        }
-        .menu-item.active {
-            background-color: #007bff; /* Example active color, adjust as needed */
-            color: white;
-        }
-        .menu-item {
-            background-color: #000000 0.7; /* Example active color, adjust as needed */
-            color: white;
-        }
-        .bottom-menu {
-            display: flex;
-            justify-content: space-around;
-            position: fixed;
-            bottom: 0;
-            left: 0;
-            right: 0;
-            width: 100%;
-            height: 50px;
-            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black */
-            color: white;
-            z-index: 1001;
-        }
-        @media (max-width: 768px) {
-            .bottom-menu {
-                height: 40px; /* Adjust for mobile */
-            }
-        }
-
-        @-webkit-keyframes active {
-            0% {
-                -webkit-transform: scale(.1);
-                opacity: 1;
-            }
-            100% {
-                -webkit-transform: scale(2.5);
-                opacity: 0;
-            }
-        }
-
-        @keyframes-blue active {
-            0% {
-                transform: scale(.1);
-                transform: box-shadow(0px 0px 0px 1px #1f41ed);
-                opacity: 1;
-            }
-            100% {
-                transform: scale(2.5);
-                opacity: 0;
-            }
-        }
-    </style>
-    <script>
-        !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.async=!0,p.src=s.api_host+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags getFeatureFlag getFeatureFlagPayload reloadFeatureFlags group updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures getActiveMatchingSurveys getSurveys onSessionId".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
-        posthog.init('phc_7JBpU7pfJomlCDgtNh0GgygKClYpYU52HOBX36qZRZx',{api_host:'https://eu.posthog.com'})
-    </script>
-</head>
+    <head>
+        <title>Cyprus Public Transit on Map</title>
+        <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
+        <link rel="stylesheet" href="css/style.css" />
+        <meta name="viewport" content="width=device-width, initial-scale=1">
+        //<link rel="icon" type="image/x-icon" href="/icons/favicon.ico">
+        <script>
+            !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.async=!0,p.src=s.api_host+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags getFeatureFlag getFeatureFlagPayload reloadFeatureFlags group updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures getActiveMatchingSurveys getSurveys onSessionId".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
+            posthog.init('phc_7JBpU7pfJomlCDgtNh0GgygKClYpYU52HOBX36qZRZx',{api_host:'https://eu.posthog.com'})
+        </script>
+        <script src="https://cdn.tailwindcss.com"></script>
+        <script>!function(t,e,a,n){function o(){if(!e.getElementById(a)){var t=e.getElementsByTagName(n)[0],o=e.createElement(n);o.type="text/javascript",o.async=!0,o.src="https://cdn.prodcamp.com/js/prdcmp-sdk.js",t.parentNode.insertBefore(o,t)}}if("function"!=typeof t.ProdCamp){var c=function(){c.args.push(arguments)};c.p="XHNWXMHQK",c.args=[],c.t=t.ProdCampSettings&&t.ProdCampSettings.token,c.f=true,t.ProdCamp=c,"complete"===e.readyState?o():t.attachEvent?t.attachEvent("onload",o):t.addEventListener("load",o,!1)}}(window,document,"prodcamp-js","script");</script>
+        <script>ProdCamp('initFeedbackWidget')</script>
+    </head>
 <body>
-<script>!function(t,e,a,n){function o(){if(!e.getElementById(a)){var t=e.getElementsByTagName(n)[0],o=e.createElement(n);o.type="text/javascript",o.async=!0,o.src="https://cdn.prodcamp.com/js/prdcmp-sdk.js",t.parentNode.insertBefore(o,t)}}if("function"!=typeof t.ProdCamp){var c=function(){c.args.push(arguments)};c.p="XHNWXMHQK",c.args=[],c.t=t.ProdCampSettings&&t.ProdCampSettings.token,c.f=true,t.ProdCamp=c,"complete"===e.readyState?o():t.attachEvent?t.attachEvent("onload",o):t.addEventListener("load",o,!1)}}(window,document,"prodcamp-js","script");</script>
-<script>
-    ProdCamp('initFeedbackWidget', {
-        email: 'random@mail.com'
-    });
-</script>
-<h3>Cyprus Buses Live</h3>
+<h2>some text</h2>
 <div id="map"></div>
 <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
-<script src="./frontend.js"></script>
-<div class="bottom-menu">
-    <div><a href="#" class="menu-item active">Map</a></div>
-    <div><a href="#" class="menu-item">Timetables (soon)</a></div>
-    <div><a href="#" class="menu-item">Routes (soon)</a></div>
-    <div><a href="#" class="menu-item">About (soon)</a></div>
+<script type="module" src="frontend.js"></script> <!-- Ensure type="module" is used -->
+<div class="flex flex-col h-screen">
+    <h3><div id="error-message" style="display: none; color: red;"></div></h3>
+    <div class="flex-1" id="map">
+        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
+
+        </div>
+    </div>
+    <div>
+        initMap(city);
+        <div class="city-selector">
+            <label for="city">Select City:</label>
+            <select id="city">
+                <option value="Limassol">Limassol</option>
+                <option value="Nicosia">Nicosia</option>
+                <option value="Larnaca">Larnaca</option>
+                <option value="Paphos">Paphos</option>
+            </select>
+            <button id="loadMap">Load Map</button>
+        </div>
+
+    </div>
+    <div class="fixed inset-x-0 bottom-0 bg-gray-200 p-4">
+        <div class="bg-white rounded-lg shadow-lg">
+            <!-- Navigation tabs -->
+
+            <div class="menu-container bg-gray-200 p-4 flex justify-around fixed bottom-0 inset-x-0 z-20">
+                <!-- Updated Map button with Tailwind CSS classes for full width, blue background, and white text -->
+                <a href="#" class="tab-button bg-blue-500 text-white px-4 py-2 rounded" data-target="main">Map</a>
+                <button class="tab-button" data-target="timetables">Timetable+Routes(soon)</button>
+                <a href="stats.html" class="tab-button" data-target="stats">Stats</a>
+                <a href="https://www.buymeacoffee.com/tonyzorin" class="tab-button" data-target="about">âï¸ Buy Me a
+                    Coffee</a>
+            </div>
+            <!-- Tabs Content --
+            <div id="map" class="tab-content hidden">Map Content Here
+                <button class="bg-gray-200 rounded-lg p-2">Map</button>
+            </div>
+            <div id="timetableTab" class="tab-content">Timetable Content Here</div>
+            <div id="routesTab" class="tab-content">Routes Content Here</div>
+            <div id="aboutTab" class="tab-content">About Content Here</div>
+            <div class="bg-white">
+                <div class="grid grid-cols-2 md:grid-cols-3 gap-4 p-4">
+                    <button class="bg-gray-200 rounded-lg p-2">Pafos</button>
+                    <button class="bg-gray-200 rounded-lg p-2">Larnaca</button>
+                    <button class="bg-gray-200 rounded-lg p-2">Agia Napa</button>
+                    <button class="bg-gray-200 rounded-lg p-2">Intercity</button>
+                    <button class="bg-gray-200 rounded-lg p-2">Nicosia</button>
+                    <button class="bg-gray-200 rounded-lg p-2">Limassol</button>
+                </div>
+            </div>-->
+        </div>
+    </div>
 </div>
-<script>
-    document.addEventListener('DOMContentLoaded', () => {
-        const menuItems = document.querySelectorAll('.menu-item');
 
-        menuItems.forEach(item => {
-            item.addEventListener('click', function() {
-                menuItems.forEach(i => i.classList.remove('active')); // Remove active class from all items
-                this.classList.add('active'); // Add active class to the clicked item
-            });
-        });
-    });
-</script>
+
+
 </body>
 </html>
